一、java 基础

1.1 请你说明 String 和 StringBuffer 的区别
	String是final修饰，每次修改都会重新创建一个新的对象
	StringBuffer可预先分配指定长度的存块建立一个字符串缓冲区。这样使用StringBuffer类的append方法追加字符比String使用 + 操作符添加字符到一个已经存在的字符串后面有效率得多
1.2 请你说明一下 int 和 Integer 有什么区别
    在java中Integer是int的包装类，int是基本类型，Integer是在对内存中存在的对象
1.3 数组(Array)和列表(ArrayList)的区别？什么时候应该使用 Array 而不是 ArrayList？
	
1.4 什么是值传递和引用传递？
	值传递就是传递参数的副本，常见的值传递都是基本类型，java对象的传递基本上都是传递的引用地址，就是引用传递
1.5 Java 支持的数据类型有哪些？什么是自动拆装箱？
	int、float、doubble、short、long、boolean、byte、char
1.6 为什么会出现 4.0-3.6=0.40000001 这种现象？
	doubble类型的数据在进行计算时因为是2进制计算，所以有时会损失精度，类似于10进制的10/3
1.7 java8 的新特性吗，请简单介绍一下
	lambada表达式，函数式编程，stream，function，
1.8 你说明符号“==”比较的是什么？
	java中Obejct==比较的是基本类型的值，对象在内存中的位置
1.9 Object 若不重写 hashCode()的话，hashCode()如何计算出来的？
	直接调用本地方法（native），用C或C++实现的，算出一个int类型的hash码来表示内存中的位置
1.10 为什么重写equals 还要重写 hashcode？
	如果只重写equals没有重写hashCode()，就会导致相同的key值也被hashcode认为是不同的key值（因为没有重写hashCode()，则任何对象的hashCode（）值都不相等），
	就会在hashmap中存储相同的key值（map中key值不能相同），这就不符合条件了。
1.11 若对一个类不重写，它的 equals()方法是如何比较的？
	基本类型对比的是值，引用类型对比的是引用对象在内存中的位置
二、关键字
2.1 Java 里面的 final 关键字是怎么用的？
	final修饰的变量不能被修改，修饰的方法不能被重写，修饰的类不能被继承
2.2 谈谈关于 Synchronized 和 lock
	synchronized
		是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能
		偏向锁：只有一个线程争抢该代码块的锁，线程获得锁之后就没有释放锁等操作了，新线程尝试获取锁发现对象已经偏向了，并且偏向的不是自己，就会发生锁争抢，此时锁升级为轻量级锁或者说自旋锁
		自旋锁：自旋锁相当于一个线程在原地等待，循环等待，直到获取到锁的线程释放锁，这个原地循环的过程，也是耗费cpu的，所以自旋锁适用于同步代码块执行很快的场景
		自适应自旋锁：线程曾经成功获取过锁，在此尝试获取锁的时候会适当增加自旋次数。线程获取锁经常是失败的情况，直接升级为重量级锁
		重量级锁（互斥锁）：重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。
			当系统检查到锁是重量级锁之后，会把等待想要获得锁的线程进行阻塞，被阻塞的线程不会消耗cup。但是阻塞或者唤醒一个线程时，都需要操作系统来帮忙，
			这就需要从用户态转换到内核态，而转换状态是需要消耗很多时间的，有可能比用户执行代码的时间还要长。这就是说为什么重量级线程开销很大的
	Lock
		是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，
		如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，
		等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到
2.3 请你介绍一下 volatile？
	内存可见，修改完成后及时刷新住内存，不是线程安全的
2.4 请你介绍一下 Syncronized 锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
	修饰静态代码和同步代码块时，锁住的是类，线程要是想执行对应同步代码，需要获得类锁
	修饰成员变量，锁住的是对象实例的对象锁
三.面向对象

3.1Java 中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？
	重写@Overriding 是子类继承父类方法，重写改方法，参数和返回类型不变，
	重载@Overloading 是在同一个类，同名的方法，入参和返回的结果不同
3.2 如何通过反射获取和设置对象私有字段的值？

3.3 请说明内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？

3.4 当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
是值传递，对象传递的是这个对象在内存中的引用，除非改变这个引用，不然都会改变这个值的本身，基本类型是传递这个的值的副本，不会影响原来的值。
3.5 什么是泛型？

3.6 解释一下类加载机制，双亲委派模型，好处是什么？

3.7”static”关键字是什么意思？Java 中是否可以覆盖(override)一个 private 或者是 static 的方法？
	因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关
	因为private修饰的变量和方法只能在当前类中使用，如果是其他的类继承当前类是不能访问到private变量或方法的，当然也不能覆盖
3.8 列举你所知道的 Object 类的方法并简要说明。
	Clone():创建并返回对象的副本	equals():对于基本数据类型，比较的是两个对象的值是否相等，对于引用数据类型来说，比较的是两个对象的地址值是否相等(是否指向堆中的同一个地址块)
	finalize():当垃圾搜集器确定不再有该对象的引用时，垃圾搜集器会进行资源的回收	getClass()：返回一个运行时候的类	hashCode():返回对象的哈希码值
	notify():用于唤醒在等待监视器的单个线程	notifyAll():唤醒所有在等待监视器的所有线程	wait(): 使得当前的线程进行等待
	wait(long time):导致当前的线程进行等待，直到另一个线程调用notify()或notifyAll()方法来唤醒，或者是等待的时间结束
3.9 类和对象的区别
	类是对象的抽象，对象是类的具体实例。
	类是抽象的，不占用内存，而对象是具体的，占有内存空间。
	例如：类就是水果，对象就是苹果

hashMap扩容机制（由数组扩容到链表）
	1.7及之前，当前存放数据是发生了hash冲突，并且当前map的数量超过了阈值
	1.8存放新值后，已有元素数量大于等于阈值
	第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，
	在同一个位置的个数又达到了8个（代码是>=7,从0开始，及第8个开始判断是否转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，
	才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。
	
io
	bio	同步阻塞 请求资源不可用时，io请求已知阻塞，直到返回结果
	nio 同步非阻塞	请求资源不可用时。io请求离开返回，返回数据标识资源不可用
B+树、B树、红黑树、AVL树、二叉树、平衡二叉树
	B树：1、多路平衡搜素树，关键字集合在整棵树中，2、任何一个关键字出现且只出现在一个结点中 3、搜索有可能在非叶子结点结束
为什么选择B+树作为数据索引？
	B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。
	那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，
	使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，
	IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。
　　另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。
	(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。
	而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)
	至于MongoDB为什么使用B-树而不是B+树，可以从它的设计角度来考虑，它并不是传统的关系性数据库，而是以Json格式作为存储的nosql，目的就是高性能，高可用，易扩展。首先它摆脱了关系模型，
	上面所述的优点2需求就没那么强烈了，其次Mysql由于使用B+树，数据都在叶节点上，每次查询都需要访问到叶节点，而MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，
	无疑单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）。	
	
	B树相对于红黑树的区别

　　在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，
	必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，
	树的深度过大会造成磁盘IO频繁读写。根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，
	可以降低树的高度。
mysql查询时in索引字段时，还是走索引的，但是内容比较大的时候基本上就会进行权标扫描了	
	
Spring bean初始化过程中怎么解决循环依赖的问题？
	通过三级缓存解决循环依赖的问题。
	Spring中有三级缓存，分别如下
		singletonObjects：完成初始化的单例对象的cache（一级缓存）
		earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）
		singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）
	获取bean的流程就是从一级到三级一次寻找这个bean。
不能解决的循环依赖的类型
	1：构造器依赖
	2：原型类型的循环依赖
		
@Scope 作用范围以及常用的集中注解值
	1.singleton单例模式, 全局有且仅有一个实例
	2.prototype原型模式, 每次获取Bean的时候会有一个新的实例
	3.request, request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，
	4.session, session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效
	5.global, session global session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，
		它被所有构成某个 portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。
		如果你在web中使用global session作用域来标识bean，那么web会自动当成session类型来使用
	
TCP/IP协议，是面向连接、的可靠的基于字节流的传输层通信协议。socket	

依赖注入（DI）：
	依赖的对象通过构造函数、工厂方法参数或者属性注入，当对象实例化后依赖的对象会被创建，创建bean后容器注入这些依赖的对象

@Bean 表示一个方法实例化、配置或者初始化一个Spring IoC容器管理的新对象
@Controller	表明被注解的类是控制component，主要用于展现层
@Service 表示被注解的类是位于业务层的业务
@Repository 用于持久层，主要是数据库存储
@Component 被@Component注解的类会被component扫描

ConcurrentHashMap 在 put一个数据时的处理的具体流程
	1、计算要 put 的 key 的位置，获取指定位置的 Segmen
	2、如果指定位置的 Segment 为空，则初始化这个 Segment
	初始化segment的流程：
		1、检查计算得到的位置的 Segment 是否为null.
		2、为 null 继续初始化，使用 Segment[0] 的容量和负载因子创建一个 HashEntry 数组。
		3、再次检查计算得到的指定位置的 Segment 是否为null.
		4、使用创建的 HashEntry 数组初始化这个 Segment.
		5、自旋判断计算得到的指定位置的 Segment 是否为null，使用 CAS 在这个位置赋值为 Segment
	3、Segment.put 插入 key,value 值
	由于 Segment 继承了 ReentrantLock，所以 Segment 内部可以很方便的获取锁，put 流程就用到了这个功能
		1、tryLock() 获取锁，获取不到使用 scanAndLockForPut 方法继续获取。
		2、计算 put 的数据要放入的 index 位置，然后获取这个位置上的 HashEntry 
	jdk1.7segment数组 + HashEntry数组 + 链表	
	jdk1.8之后采用node数组 + 链表/红黑树	