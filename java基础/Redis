1、如何保证redis和数据库双写一致性。
	先删除缓存，然后更新数据库。这样就能保证及时数据库更新失败，用户查询获取的还是和数据库保持一致的值
	流量大高并发场景下，可能出现删除缓存后，更新数据还未更新完成时，另外线程查询数据库，把数据库的旧值放在了缓存中，出现缓存不一致的情况
	此种情况。将数据库与缓存的更新和读取操作串行化
2、Redis的线程模型？
	Redis的线程模型是单线程模式，绝大部分请求时纯粹的内存操作，数据结构类似于HashMap，查询速度非常快。
3、缓存雪崩
	统一时间缓存大面失效（例：缓存服务器宕机）
	解决方法，开启本地缓存ehcache，启用限流组件，设置每秒请求数量，多出的请求设置默认返回值。
4、缓存穿透、缓存击穿
	缓存穿透：大量的Redis中不存在的请求访问，直接打入数据库。类似于恶意攻击。  解决方法，数据库中没查到数据，就缓存空值Redis中，并设置很短的一个过期时间
				将所有的数据存到一个非常大的bitmap中，采用布隆过滤器记录这些为空的key，再次访问就会被拦截掉
	缓存击穿：某个key被访问的非常频繁，当这个key失效的瞬间，将会有大量的请求就会击穿缓存，直接到数据库，
				比较常用的解决方法使用互斥锁，缓存失效时不是立即去load db，而是先使用缓存工具自带的返回值去set一个mutex key，当操作返回成功时再进行load db操作，否则就重试整个get方法。   
缓存使用的场景
	高性能、高并发
		读取操作时，不用频繁的去读取数据库，缓存中拿更加高效
		数据库扛不住高并发，redis是走内存的，天然可以支撑高并发
Redis的数据类型
	String Hash List Set SortSet
Redis实现分布式锁
	RedLock算法是redis支持的官方的分布式锁算法，三个特点
	1、互斥（只有一个客户端可以获取锁）
	2、不能死锁
	3、容错 只要大部分Redis创建了这把锁就可以
redis采用异步方式复制数据到slave节点，
	一主多从的配置方式	
	从节点(slave node)在做复制的时候，不会阻塞主节点的正常工作
	从节点也可以连接其他的从节点
	从节点在进行复制操作的时候，也不会影响自己的查询操作，会用旧数据集提供服务，复制完成，删除就数据集。加载新数据集时，会暂停对外服务
	从节点主要用来做横向扩容，做读写分离，扩容的从节点可以提高读的吞吐量
主从架构需要开启主节点的持久化，不建议把从节点作为主节点的数据备热，因为这样如果关掉主节点的持久化，可能master节点宕机时数据是空的，同步到从节点导致从节点数据也为空
启动一个slave node时，会发送一个PSYNC命令给master node时，会发送一个PSYNC命令给master		
	过期删除加惰性删除 LRU算法
主从复制的断点续传	