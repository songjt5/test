ThreadLocal：线程本都变量，主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。每个线程可以访问自己内部的副本变量，线程之间互不影响
	每个Thread线程内部都有一个ThreadLocalMap，用来存储线程本地对象为key以及变量副本value
	Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向Map获取和设置线程的变量值
	这样对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，这样就形成了副本隔离，互不干扰。
ThreadLocal类提供了以下几个核心方法：
	1.get方法：获取当前线程的副本变量值
		1.获取当前线程的ThreadLocalMap对象threadLocals（实际储存副本值的Map）
		2.Map不为空的话，从Map中获取线程储存的K-V Entry结点，然后从Entry结点中获取Value副本值返回
		3.Map为空的话，返回初始值null，之后还需向Map中添加value为null的键值对，避免空指针异常
	2.set方法：设置当前线程的副本变量值
		1.源码是先尝试获取当前线程的成员变量Map
		2.若Map不为空：重新将ThreadLocal对象和Value副本放入Map中
		3.Map为空：对线程成员变量ThreadLocalMap进行初始化创建，并将ThreadLocal对象和Value副本放入Map中
	3.remove方法：移除当前线程的副本变量值
		直接调用了ThreadLocalMap的remove方法
	4.initilaValue方法：初始化当前线程的副本变量值，初始化null
ThreadLocalMap的底层源码分析
	ThreadLocalMap是ThreadLocal内部的一个Map实现，内部使用数据结构采用数组+开方地址法，Entry继承WeakRefrence，是基于ThreadLocal这种特殊场景实现的Map
	1.ThreadLocalMap中Entry
		1.Entry中key只能是ThreadLocal对象，被规定死了的
		2.Entry继承了WeakRefrence（弱引用，生存周期只能活到下次GC前），但是只有Key是弱引用，Value并不是弱引用
		value既然不是弱引用，那么key在被回收之后(key=null)Value并没有被回收，如果当前线程被回收了那还好，这样value也和线程一起被回收了，要是当前线程是线程池这样的环境，
		线程结束没有销毁回收，那么Value永远不会被回收，当存在大量这样的value的时候，就会产生内存泄漏
		java8 在使用ThreadLocalMap的set方法，for循环遍历整个Entry数组，遇到key=null的就会替换。
		ThreaLocalMap的key是ThreaLocal，它不会传统的调用ThreadLocal的hashcode方法（继承自object的hashcode），而是调用nexthashcode
	2.ThreadLocalMap中set
		ThreadLocalMap在set时先计算key的hashCode，如果说已经存在key直接进行替换，即使出现key为null的情况也是进行直接替换，
			如果说不存在插入的key，直接新增一个Entry，然后判断是否需要扩容和清楚过期的值
java引用方式
	强引用（StrongReference）
		具备强引用的对象，垃圾回收机制不会回收它，说明它正在被使用
	软引用（SoftReference）
		如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存
	弱引用（WeakReference）
		弱引用的对象拥有更短暂的生命周期，圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
	虚引用（PhantomReference）
		与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收