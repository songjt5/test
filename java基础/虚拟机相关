线程共享的内存区域
	方法区内存中放的东西（元空间）
		常量  静态变量  类信息
		运行时常量池：Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）
	堆
		Eden S1 S2 老年代
	直接内存（非运行数据区的一部分）	
线程私有的内存区域
	虚拟机栈
		局部变量表
		操作数栈
		动态链接
		方法出口
		Java虚拟机栈会出现两种错误：StackOverFlowError和OutOfMemoryError。
		StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError 错误。
		OutOfMemoryError：若Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError错误	
	本地方法栈
		同虚拟机栈一样
		本地方法（native）需要的内存空间
	程序计数器
		程序计数器是一块较小的内存空间，可以看作是线程执行时的字节码的行号指示器。
		程序计数器主要有两个作用：
			字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
			在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
		程序计数器是唯一一个不会发生内存溢出的内存区域，它的生命周期随着线程的创建而产生，随着线程的
gc的算法
    标记清理 Mark Sweep	位置不连续，容易产生空间碎片
	复制算法 Copying	没有碎片，浪费空间
	标记整理 Mark Compact 没有碎片，效率偏低
    可达性分析算法，已GCroots中根节点出发，开始向下搜索引用的对象，（引用或者间接引用），找到的对象都是非垃圾的
    GcRoots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等。
    minorGC回收的是整个新生代的对象
    fullGC回收的是整个堆内存的对象
集中常见的垃圾收集算法
	G1 CMS 
判断是否是大对象的标准：其大小是否超过survivor内存的一半，这个可以通过 -XX:MaxTenuringThreshold 设置
survivor每移动一次其年龄加1，默认超过15岁会将其移至老年代
常见的内存溢出的场景：
	OutOfMemoryError: GC Overhead Limit Exceeded :当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
	java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发
	java.lang.OutOfMemoryError: Java heap space :错误。(和本机物理内存无关，和你配置的内存大小有关！)	
方法区和永久代的关系
	《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的JVM上方法区的实现肯定是不同的了。
	方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 
	也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法	
为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
	元空间可以使用的是直接内存，受本机内存的限制。永久代需要设置一个固定大小上限，无法进行调整。使用元空间内存溢出的概率会小很多
	