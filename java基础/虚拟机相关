线程共享的内存区域
	方法区内存中放的东西（元空间）
		常量  静态变量  类信息
		运行时常量池：Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）
	堆
		存放对象实例，几乎所有的对象和数组都在这里分配内存
		Eden S1 S2 老年代
		从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存.
	直接内存（非运行数据区的一部分）	
线程私有的内存区域
	虚拟机栈
		局部变量表	存储已知的各种基本数据类型（8种基本数据类型）和对象的引用（reference类型，不同于对象本身，是指向对象地址的引用指针）
		操作数栈
		动态链接
		方法出口
		Java虚拟机栈会出现两种错误：StackOverFlowError和OutOfMemoryError。
		StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError 错误。
		OutOfMemoryError：若Java虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出OutOfMemoryError错误	
	本地方法栈
		同虚拟机栈一样
		本地方法（native）需要的内存空间
	程序计数器
		程序计数器是一块较小的内存空间，可以看作是线程执行时的字节码的行号指示器。
		程序计数器主要有两个作用：
			字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
			在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
		程序计数器是唯一一个不会发生内存溢出的内存区域，它的生命周期随着线程的创建而产生，随着线程的
gc的算法
    标记清理 Mark Sweep	位置不连续，容易产生空间碎片
	复制算法 Copying	没有碎片，浪费空间
	标记整理 Mark Compact 没有碎片，效率偏低
    可达性分析算法，已GCroots中根节点出发，开始向下搜索引用的对象，（引用或者间接引用），找到的对象都是非垃圾的
	引用计数法 给对象添加一个引用计数器，每当一个地方引用它，计数器就加1；当引用失效，计数器减1，任何计数器为0的对象就是不能被使用的对象
		存在对象互相引用的问题，对象A和对象B互相引用，这样就永远不会被清除
    GcRoots根节点：线程栈的本地变量、静态变量、本地方法栈（native方法）的变量，虚拟机栈种引用的对象，方法去中常量引用的对象 等等。
    minorGC回收的是整个新生代的对象
    fullGC回收的是整个堆内存的对象
集中常见的垃圾收集算法
	G1（分代收集） 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.
		分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念
		空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的
		并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。
			部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行
		可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，
			还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内	
		具体过程分为四个步骤：初始标记、并发标记、最终标记、筛选回收
	CMS（标记清理）以最短回收停顿时间为目标的收集器，比较注重用户体验的应用上。优点在于，并发收集、低停顿
		是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
		具体清楚过程可分为四个步骤：
			初始标记：暂停所有线程，并标记下直接与root连接的对象，速度很快
			并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。
				因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
			重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，
				这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短	
			并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。	
	Serial 收集器 单线程垃圾收集，垃圾收集时会暂停掉其它所有线程（Stop the world），直到收集结束
	ParNew 收集器 多线程进行垃圾收集 新生代采用 标记-复制算法，老年代采用 标记-整理算法
	Parallel Scavenge 收集器  也是使用标记-复制算法的多线程收集器，老年代时标记-整理算法，几乎和 ParNew 都一样，区别在于它关注的时吞吐量。 jdk1.8默认的垃圾收集器
	Serial Old 收集器  同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案
	Parallel Old 收集器  使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器
大对象直接进入老年代	
判断是否是大对象的标准：其大小是否超过survivor内存的一半，这个可以通过 -XX:MaxTenuringThreshold 设置
survivor每移动一次其年龄加1，默认超过15岁会将其移至老年代，年龄阈值可以通过-XX:MaxTenuringThreshold 来设置
常见的内存溢出的场景：
	OutOfMemoryError: GC Overhead Limit Exceeded :当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
	java.lang.OutOfMemoryError: Java heap space :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发
	java.lang.OutOfMemoryError: Java heap space :错误。(和本机物理内存无关，和你配置的内存大小有关！)	
方法区和永久代的关系
	《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的JVM上方法区的实现肯定是不同的了。
	方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 
	也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法	
为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
	元空间可以使用的是直接内存，受本机内存的限制。永久代需要设置一个固定大小上限，无法进行调整。使用元空间内存溢出的概率会小很多
	