B+树、B树、红黑树、AVL树、二叉树、平衡二叉树
	B树：1、多路平衡搜素树，关键字集合在整棵树中，2、任何一个关键字出现且只出现在一个结点中 3、搜索有可能在非叶子结点结束
为什么选择B+树作为数据索引？
	B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。
	那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，
	使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，
	IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。
　　另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。
	(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。
	而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)
	至于MongoDB为什么使用B-树而不是B+树，可以从它的设计角度来考虑，它并不是传统的关系性数据库，而是以Json格式作为存储的nosql，目的就是高性能，高可用，易扩展。首先它摆脱了关系模型，
	上面所述的优点2需求就没那么强烈了，其次Mysql由于使用B+树，数据都在叶节点上，每次查询都需要访问到叶节点，而MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，
	无疑单次查询平均快于Mysql（但侧面来看Mysql至少平均查询耗时差不多）。

	B树相对于红黑树的区别

Mysql 索引类型（由于B+树特性，建立索引能够大大提升查询效率）：
    1.普通索引
    2.唯一索引：唯一索引列的值必须唯一允许有空值，如果是组合索引，则列值的组合必须唯一：
        CREATE UNIQUE INDEX indexName ON mytable(username(length)) -- 修改表结构
        ALTER mytable ADD UNIQUE [indexName] ON (username(length)) -- 创建表的时候直接指定
        CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16)
        NOT NULL, UNIQUE [indexName] (username(length)) );
    3.主键索引：一种特殊的唯一索引，不允许有空值，一般在创建表的时候创建主键索引：
        CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) );
    4.组合索引：CREATE TABLE mytable( ID INT NOT NULL, username
        VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL );
        为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。就是将 name, city, age 建到一个索引里：代码如下:
        ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age);
什么情况下有索引，但用不上？
    1.如果条件中有 OR，即使其中有部分条件带索引也不会使用。注意：要想使用 or，又想让索引生效，只能将 or 条件中的每个列都加上索引。
    2.对于多列索引，不是使用的第一部分，则不会使用索引。
    3.Like 查询以%开头，不使用索引
    4.存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
    5.Where 子句里对索引列上有数学运算，用不上索引
    6.Where 子句中对索引列使用函数，用不上索引
    7.Mysql 估计使用全表扫描要比用索引快，不使用索引
什么情况下不推荐使用索引
    1.数据唯一性差的字段不建议使用索引
    2.频繁被更新的字段
    3.字段不在 where 语句中出现时不要添加索引，如果 where 后含IS NULL/IS NOT NULL/LIKE ‘%输入符%’等条件，不要使用索引
    4.Where 子句里对索引使用不等于（<>），不建议使用索引，效果一般
